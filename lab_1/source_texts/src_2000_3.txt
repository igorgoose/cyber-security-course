tories the difference between using filesystemxmlapplicationcontext and classpathxmlapplicationcontext is that filesystemxmlapplicationcontext looks for knight xml in a specific location within the filesystem whereas classpathxmlapplicationcontext looks for knight xml anywhere in the classpath including jar files instead of specifying an xml file from which to load the spring application context annotationconfigapplicationcontext has been given a configuration class from which to load beans with an application context in hand you can retrieve beans from the spring container by calling the contexts getbean method now that you know the basics of how to create a spring container lets take a closer look at the lifecycle of a bean in the bean container in a traditional java application the lifecycle of a bean is simple javas new keyword is used to instantiate the bean and its ready to use once the bean is no longer in use its eligible for garbage collection and eventually goes to the big bit bucket in the sky in contrast the lifecycle of a bean in a spring container is more elaborate its important to understand the lifecycle of a spring bean because you may want to take advantage of some of the opportunities that spring offers to customize how a bean is created spring instantiates the bean spring injects values and bean references into the beans properties if the bean implements beannameaware spring passes the beans id to the setbeanname method if the bean implements beanfactoryaware spring calls the setbeanfactory method passing in the bean factory itself if the bean implements applicationcontextaware spring calls the setapplicationcontext method passing in a reference to the enclosing application context if the bean implements the beanpostprocessor interface spring calls its postprocessbeforeinitialization method if the bean implements the initializingbean interface spring calls its afterpropertiesset method similarly if the bean was declared with an initmethod then th